'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var colors = require('../colors');
var objects = require('../objects');
var optimization = require('../optimization');

/**
 * @param {array[][]} list
 * @return {array[][]}
 */
function processQuadList(list) {
    var keys = list.map(function (v) {
        return v[1].toString();
    });
    if (keys.length === 4 && keys[0] == keys[1] && keys[1] === keys[2] && keys[2] === keys[3]) {
        return [list[0]];
    }
    if (keys.length === 4 && keys[0] === keys[2] && keys[1] === keys[3]) {
        return processQuadList([list[0], list[1]]);
    } else if (keys.length === 4 && keys[1] === keys[3]) {
        return processQuadList(list.slice(0, 3));
    }
    if (keys.length === 3 && keys[0] === keys[2]) {
        return processQuadList(list.slice(0, 2));
    }
    if (keys.length === 2 && keys[0] === keys[1]) {
        return list.slice(0, 1);
    }

    return list;
}

module.exports = function () {
    /**
     * @constructor
     * @param {array[]} chain
     */
    function Expression(chain) {
        _classCallCheck(this, Expression);

        this.chain = chain;
    }

    /**
     * @return {string}
     */


    _createClass(Expression, [{
        key: 'toString',
        value: function toString() {
            return this.chain.reduce(function (acc, cur, i) {
                if (i) {
                    acc += cur[0] || ' ';
                }
                acc += cur[1].toString();
                return acc;
            }, '');
        }

        /**
         * @param {int} indent
         * @return {string}
         */

    }, {
        key: 'pretty',
        value: function pretty(indent) {
            return this.chain.reduce(function (acc, cur, i) {
                if (i) {
                    if (cur[0] === ',') {
                        acc += ', ';
                    } else if (!cur[0]) {
                        acc += ' ';
                    } else {
                        acc += cur[0];
                    }
                }
                var val = cur[1];
                return acc + (val.pretty ? val.pretty(indent) : val.toString());
            }, '');
        }

        /**
         * @param {object} kw
         * @return {Expression}
         */

    }, {
        key: 'optimize',
        value: function optimize(kw) {
            this.chain = this.chain.map(function (v) {
                return [v[0], optimization.try_(v[1], kw)];
            }).filter(function (v) {
                return !!v[1];
            });
            if (!this.chain.length) {
                return null;
            }

            if (!kw.declarationName) return this;

            // OPT: Try to minify lists of lengths.
            // e.g.: `margin:0 0 0 0` -> `margin:0`
            if (kw.declarationName in optimization.quadLists && this.chain.length > 1 && this.chain.length < 5 && this.chain.every(function (c) {
                return c[0] !== '/';
            })) {
                this.chain = processQuadList(this.chain);
            } else if (kw.declarationName === 'border-radius' && this.chain.some(function (x) {
                return x[0] === '/';
            })) {
                var slashIdx = this.findSlash();
                var leftChain = optimization.expandQuadList(this.chain.slice(0, slashIdx));
                var rightChain = optimization.expandQuadList(this.chain.slice(slashIdx).map(function (x) {
                    return [null, x[1]];
                }));

                if (leftChain.every(function (x, i) {
                    return x[1].toString() === rightChain[i][1].toString();
                })) {
                    this.chain = processQuadList(leftChain);
                } else {
                    var pLeftChain = processQuadList(leftChain);
                    var pRightChain = processQuadList(rightChain);

                    pRightChain[0][0] = '/';
                    this.chain = pLeftChain.concat(pRightChain);
                }
            } else if (kw.declarationName === 'font-weight' || kw.declarationName === 'font') {
                this.chain = this.chain.map(function (chunk) {
                    // OPT: font/font-weight: normal -> 400
                    if (chunk[1].toString() === 'normal') {
                        return [chunk[0], '400'];
                    }
                    // OPT: font/font-weight: bold -> 700
                    else if (chunk[1].toString() === 'bold') {
                            return [chunk[0], '700'];
                        } else {
                            return chunk;
                        }
                });
            } else if (kw.o1 && kw.declarationName === 'content' && this.chain[0][1] === 'none') {
                // OPT: `content:none` -> `content:""`
                this.chain[0][1] = new objects.String('');
            } else if (kw.declarationName === 'display' && this.chain.length > 1) {
                var sec = this.chain[1][1];
                switch (this.chain[0][1]) {
                    case 'block':
                        if (sec === 'flow') {
                            this.chain.splice(1, 1);
                        } else if (sec === 'flow-root') {
                            this.chain = [[null, 'flow-root']];
                        } else if (sec === 'flex') {
                            this.chain = [[null, 'flex']];
                        } else if (sec === 'grid') {
                            this.chain = [[null, 'grid']];
                        } else if (sec === 'table') {
                            this.chain = [[null, 'table']];
                        }
                        break;
                    case 'inline':
                        if (sec === 'flow') {
                            this.chain.splice(1, 1);
                        } else if (sec === 'flow-root') {
                            this.chain = [[null, 'inline-block']];
                        } else if (sec === 'flex') {
                            this.chain = [[null, 'inline-flex']];
                        } else if (sec === 'grid') {
                            this.chain = [[null, 'inline-grid']];
                        } else if (sec === 'ruby') {
                            this.chain = [[null, 'ruby']];
                        } else if (sec === 'table') {
                            this.chain = [[null, 'inline-table']];
                        }
                        break;
                    case 'run-in':
                        if (sec === 'flow') {
                            this.chain.splice(1, 1);
                        }
                        break;
                    case 'list-item':
                        if (this.chain.length === 3 && this.chain[2][1] === 'flow') {
                            if (sec === 'block') {
                                this.chain = [[null, 'list-item']];
                            } else if (sec === 'inline') {
                                this.chain = [[null, 'inline-list-item']];
                            }
                        }
                        break;
                    case 'table-cell':
                    case 'table-caption':
                    case 'ruby-base':
                    case 'ruby-text':
                        if (sec === 'flow') {
                            this.chain.splice(1, 1);
                        }
                }
            }

            if (kw.declarationName in optimization.noneables && this.chain.length === 1 && this.chain[0][1].toString() === 'none') {
                // OPT: none -> 0 where possible.
                this.chain[0][1] = '0';
            }

            // OPT: Convert color names to hex when possible.
            this.chain.forEach(function (term) {
                if (typeof term[1] === 'string' && term[1] in colors.COLOR_TO_HEX) {
                    term[1] = new objects.HexColor(colors.COLOR_TO_HEX[term[1]]);
                }
            });

            if (!this.chain.length) {
                return null;
            }

            return this;
        }

        /**
         * @return {int}
         */

    }, {
        key: 'findSlash',
        value: function findSlash() {
            return this.chain.findIndex(function (x) {
                return x[0] === '/';
            });
        }
    }]);

    return Expression;
}();