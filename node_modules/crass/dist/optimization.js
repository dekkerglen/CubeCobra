'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var colors = require('./colors');
var objects = require('./objects');
var utils = require('./utils');

var mergeRulesets = require('./optimizations/mergeRulesets');

module.exports.quadLists = {
    'border-color': 1,
    '-webkit-border-radius': 1,
    '-moz-border-radius': 1,
    'border-radius': 1,
    'border-style': 1,
    'border-width': 1,
    'margin': 1,
    'padding': 1
};

module.exports.noneables = {
    'border': 1,
    'border-top': 1,
    'border-right': 1,
    'border-bottom': 1,
    'border-left': 1,
    'outline': 1,
    'background': 1
};

var overrideList = module.exports.overrideList = {
    'animation-delay': ['animation'],
    'animation-direction': ['animation'],
    'animation-duration': ['animation'],
    'animation-fill-mode': ['animation'],
    'animation-iteration-count': ['animation'],
    'animation-name': ['animation'],
    'animation-play-state': ['animation'],
    'animation-timing-function': ['animation'],
    '-moz-animation-delay': ['-moz-animation'],
    '-moz-animation-direction': ['-moz-animation'],
    '-moz-animation-duration': ['-moz-animation'],
    '-moz-animation-fill-mode': ['-moz-animation'],
    '-moz-animation-iteration-count': ['-moz-animation'],
    '-moz-animation-name': ['-moz-animation'],
    '-moz-animation-play-state': ['-moz-animation'],
    '-moz-animation-timing-function': ['-moz-animation'],
    '-o-animation-delay': ['-o-animation'],
    '-o-animation-direction': ['-o-animation'],
    '-o-animation-duration': ['-o-animation'],
    '-o-animation-fill-mode': ['-o-animation'],
    '-o-animation-iteration-count': ['-o-animation'],
    '-o-animation-name': ['-o-animation'],
    '-o-animation-play-state': ['-o-animation'],
    '-o-animation-timing-function': ['-o-animation'],
    '-webkit-animation-delay': ['-webkit-animation'],
    '-webkit-animation-direction': ['-webkit-animation'],
    '-webkit-animation-duration': ['-webkit-animation'],
    '-webkit-animation-fill-mode': ['-webkit-animation'],
    '-webkit-animation-iteration-count': ['-webkit-animation'],
    '-webkit-animation-name': ['-webkit-animation'],
    '-webkit-animation-play-state': ['-webkit-animation'],
    '-webkit-animation-timing-function': ['-webkit-animation'],
    'background-clip': ['background'],
    'background-origin': ['background'],
    'border-color': ['border'],
    'border-style': ['border'],
    'border-width': ['border'],
    'border-bottom': ['border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-bottom-left-radius': ['border-radius'],
    'border-bottom-right-radius': ['border-radius'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left': ['border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-right': ['border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-top': ['border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-top-left-radius': ['border-radius'],
    'border-top-right-radius': ['border-radius'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'font-family': ['font'],
    'font-size': ['font'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'line-height': ['font'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'margin-right': ['margin'],
    'margin-top': ['margin'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'padding-right': ['padding'],
    'padding-top': ['padding'],
    'text-decoration-color': ['text-decoration'],
    'text-decoration-line': ['text-decoration'],
    'text-decoration-style': ['text-decoration'],
    'text-emphasis-color': ['text-emphasis'],
    'text-emphasis-style': ['text-emphasis'],
    'transition-delay': ['transition'],
    'transition-duration': ['transition'],
    'transition-property': ['transition'],
    'transition-timing-function': ['transition'],
    '-moz-transition-delay': ['-moz-transition'],
    '-moz-transition-duration': ['-moz-transition'],
    '-moz-transition-property': ['-moz-transition'],
    '-moz-transition-timing-function': ['-moz-transition'],
    '-o-transition-delay': ['-o-transition'],
    '-o-transition-duration': ['-o-transition'],
    '-o-transition-property': ['-o-transition'],
    '-o-transition-timing-function': ['-o-transition'],
    '-webkit-transition-delay': ['-webkit-transition'],
    '-webkit-transition-duration': ['-webkit-transition'],
    '-webkit-transition-property': ['-webkit-transition'],
    '-webkit-transition-timing-function': ['-webkit-transition']
};
// TODO: This will be useful eventually.
// const invertedOverrideList = Object.keys(overrideList).reduce((acc, cur) => {
//     const overriders = overrideList[cur];
//     overriders.forEach(orr => {
//         if (!(orr in acc)) {
//             acc[orr] = [cur];
//         } else {
//             acc[orr].push(cur);
//         }
//     });
//     return acc;
// }, {});

var defaultShorthandExpressionQualifier = function defaultShorthandExpressionQualifier(decl) {
    return decl.expr.chain.length === 1;
};
var defaultShorthandExpressionBuilder = function defaultShorthandExpressionBuilder(rules) {
    return rules.map(function (rule) {
        return rule.expr.chain[0];
    });
};
var defaultShorthandMerger = function defaultShorthandMerger(shChain, lhChain, idx) {
    return expandQuadList(shChain).map(function (x, i) {
        return i === idx ? lhChain[0] : x;
    });
};
var expandQuadList = module.exports.expandQuadList = function (chain) {
    if (chain.length === 4) {
        return chain;
    } else if (chain.length === 3) {
        return chain.concat([chain[1]]);
    } else if (chain.length === 2) {
        return chain.concat(chain);
    } else if (chain.length === 1) {
        return chain.concat(chain).concat(chain).concat(chain);
    }
};
var shorthandMapping = [{
    name: 'border-color',
    decls: ['border-top-color', 'border-right-color', 'border-bottom-color', 'border-left-color'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    shorthandMerger: defaultShorthandMerger
}, {
    name: 'border-style',
    decls: ['border-top-style', 'border-right-style', 'border-bottom-style', 'border-left-style'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    shorthandMerger: defaultShorthandMerger
}, {
    name: 'border-width',
    decls: ['border-top-width', 'border-right-width', 'border-bottom-width', 'border-left-width'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    shorthandMerger: defaultShorthandMerger
}, {
    name: 'margin',
    decls: ['margin-top', 'margin-right', 'margin-bottom', 'margin-left'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    shorthandMerger: defaultShorthandMerger
}, {
    name: 'padding',
    decls: ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    shorthandMerger: defaultShorthandMerger
}, {
    name: 'border',
    decls: ['border-width', 'border-style', 'border-color'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    canMerge: function canMerge(shChain, lhChain, idx) {
        // TODO: maybe there's a way to do more?
        return shChain.length === 3 && lhChain.length === 1;
    },
    shorthandMerger: function shorthandMerger(shChain, lhChain, idx) {
        return shChain.map(function (x, i) {
            return i === idx ? lhChain[0] : x;
        });
    }
}, {
    name: 'border',
    decls: ['border-top', 'border-right', 'border-bottom', 'border-left'],
    declQualifies: function declQualifies() {
        return true;
    },
    allDeclsQualify: function allDeclsQualify(decls) {
        var first = decls[0];
        var rest = decls.slice(1);
        return rest.every(function (x) {
            return x.expr.chain.length === first.expr.chain.length && first.expr.chain.every(function (item, i) {
                return x.expr.chain[i][1].toString() === item[1].toString();
            });
        });
    },
    canMerge: function canMerge(shChain, lhChain) {
        return shChain.every(function (x, i) {
            return x[1].toString() === lhChain[i][1].toString();
        });
    },
    expressionBuilder: function expressionBuilder(rules) {
        return rules[0].expr.chain;
    },
    shorthandMerger: function shorthandMerger(shChain) {
        return shChain;
    }
}, {
    name: 'text-decoration',
    decls: ['text-decoration-line', 'text-decoration-style', 'text-decoration-color'],
    declQualifies: function declQualifies(decl) {
        return decl.expr.chain.length >= 1;
    },
    expressionBuilder: function expressionBuilder(rules) {
        return rules.reduce(function (a, b) {
            return a.concat(b.expr.chain);
        }, []);
    },
    canMerge: false // TODO: maybe there's a way?
}, {
    name: 'text-emphasis',
    decls: ['text-emphasis-style', 'text-emphasis-color'],
    declQualifies: defaultShorthandExpressionQualifier,
    expressionBuilder: defaultShorthandExpressionBuilder,
    canMerge: false // TODO: maybe there's a way?
}, {
    name: 'border-radius',
    decls: ['border-top-left-radius', 'border-top-right-radius', 'border-bottom-right-radius', 'border-bottom-left-radius'],
    declQualifies: function declQualifies(decl) {
        return decl.expr.chain.length === 1 || decl.expr.chain.length === 2;
    },
    expressionBuilder: function expressionBuilder(rules) {
        var prefix = rules.map(function (rule) {
            return rule.expr.chain[0];
        });
        if (rules.every(function (rule) {
            return rule.expr.chain.length === 1;
        })) {
            return prefix;
        }
        var suffix = rules.map(function (rule) {
            return rule.expr.chain[1] || rule.expr.chain[0];
        });
        suffix[0][0] = '/';
        return prefix.concat(suffix);
    },
    shorthandMerger: function shorthandMerger(shChain, lhChain, i) {
        var hasSlash = shChain.some(function (x) {
            return x[0] === '/';
        });
        // Check for the easy path
        if (!hasSlash && lhChain.length === 1) {
            shChain = expandQuadList(shChain);
            shChain[i] = [null, lhChain[0][1]];
            return shChain;
        }

        var slashIdx = 0;
        for (var _i = 1; _i < shChain.length; _i++) {
            if (shChain[_i][0] === '/') {
                slashIdx = _i;
                break;
            }
        }

        var preSlash = expandQuadList(shChain.slice(0, slashIdx)).map(function (x) {
            return [null, x[1]];
        });
        var postSlash = expandQuadList(shChain.slice(slashIdx)).map(function (x) {
            return [null, x[1]];
        });

        preSlash[i][1] = lhChain[0][1];
        postSlash[i][1] = lhChain[1] ? lhChain[1][1] : lhChain[0][1];

        postSlash[0][0] = '/';

        return preSlash.concat(postSlash);
    }
}];
var shorthandMappingMapped = shorthandMapping.reduce(function (acc, cur) {
    if (cur.name in acc) {
        acc[cur.name].push(cur);
    } else {
        acc[cur.name] = [cur];
    }
    return acc;
}, {});

var optimizeList = module.exports.optimizeList = function (list, kw) {
    var output = [];
    for (var i = 0; i < list.length; i++) {
        var temp = list[i].optimize(kw);
        if (!temp) continue;
        output.push(temp);
    }
    return output;
};

function _combineAdjacentRulesets(content, kw) {
    var didChange = false;
    var newContent = [];
    var lastPushed = void 0;

    // A map of selectors to rulesets in this block.
    var selectorMap = {};

    var pushSel = function pushSel(sel, temp) {
        var strSel = sel.toString();

        if (!(strSel in selectorMap)) {
            selectorMap[strSel] = [temp];
            return;
        }
        for (var i = 0; i < selectorMap[strSel].length; i++) {
            var ruleset = selectorMap[strSel][i];
            var firstRuleset = ruleset.ruleset;
            if (!firstRuleset) continue;
            // We can't remove declarations from a ruleset that's shared by multiple selectors.
            if (!ruleset.canRemoveFrom) return;
            var intersection = lastPushed.declarationIntersections(firstRuleset);
            // If there's no overlap, there's nothing to do.
            if (!intersection.length) return;
            // Remove each of the intersected declarations from the initial ruleset.
            for (var j = 0; j < intersection.length; j++) {
                firstRuleset.removeDeclaration(intersection[i]);
            }

            if (!firstRuleset.content.length) {
                newContent[ruleset.index] = ruleset.ruleset = null;
            }
            // Mark that a change did occur.
            didChange = true;
        }
        selectorMap[strSel].push(temp);
    };

    for (var i = 0; i < content.length; i++) {
        var areAdjacentRulesets = lastPushed && content[i] instanceof objects.Ruleset && lastPushed instanceof objects.Ruleset;
        var areAdjacentMediaBlocks = lastPushed && content[i] instanceof objects.Media && lastPushed instanceof objects.Media;

        if (areAdjacentRulesets && lastPushed.contentToString() === content[i].contentToString()) {

            // Step 1: Merge the selectors
            if (lastPushed.selector instanceof objects.SelectorList) {
                if (content[i].selector instanceof objects.SelectorList) {
                    lastPushed.selector.selectors = lastPushed.selector.selectors.concat(content[i].selector.selectors);
                } else {
                    lastPushed.selector.selectors.push(content[i].selector);
                }
            } else if (content[i].selector instanceof objects.SelectorList) {
                content[i].selector.selectors.push(lastPushed.selector);
                lastPushed.selector = content[i].selector;
            } else {
                lastPushed.selector = new objects.SelectorList([lastPushed.selector, content[i].selector]);
            }

            // Step 2: Optimize the new selector
            lastPushed.selector = lastPushed.selector.optimize(kw);

            didChange = true;
            continue;
        } else if (areAdjacentRulesets && lastPushed.selector.toString() === content[i].selector.toString()) {

            // Step 1: Combine the content of the adjacent rulesets.
            lastPushed.content = lastPushed.content.concat(content[i].content);

            // Step 2: Re-optimize the ruleset body.
            lastPushed.optimizeContent(kw);

            didChange = true;
            continue;
        } else if (
        // OPT: Combine adjacent media blocks
        areAdjacentMediaBlocks && lastPushed.mediaQueriesToString() === content[i].mediaQueriesToString()) {
            var _lastPushed$content;

            (_lastPushed$content = lastPushed.content).push.apply(_lastPushed$content, _toConsumableArray(content[i].content));
            lastPushed.optimizeContent(kw);

            didChange = true;
            continue;
        }

        newContent.push(lastPushed = content[i]);
        // OPT: Remove declarations that are overridden later in the stylesheet.
        if (lastPushed instanceof objects.Ruleset) {
            var hasSelectorList = lastPushed.selector instanceof objects.SelectorList;
            var temp = {
                ruleset: lastPushed,
                index: newContent.length - 1,
                canRemoveFrom: !hasSelectorList
            };

            if (hasSelectorList) {
                for (var j = 0; j < lastPushed.selector.selectors.length; j++) {
                    pushSel(lastPushed.selector.selectors[j], temp);
                }
            } else {
                pushSel(lastPushed.selector, temp);
            }
        }
    }

    return didChange ? newContent.filter(function (x) {
        return x;
    }) : content;
}

module.exports.optimizeBlocks = function (content, kw) {

    content = optimizeList(content, kw);

    // OPT: Remove duplicate blocks.
    if (kw.o1) {
        var values = {};
        var removalMap = [];
        for (var i = 0; i < content.length; i++) {
            var lval = content[i].toString();
            if (lval in values) removalMap[values[lval]] = true;
            values[lval] = i;
        }
        if (removalMap.length) {
            // Don't create a new array if nothing changed.
            content = content.filter(function (elem, i) {
                return !removalMap[i];
            });
        }
    }

    // OPT: Combine nearby rulesets
    if (kw.o1 && content.length > 1) {
        for (var _i2 = 0; _i2 < content.length - 1; _i2++) {
            for (var j = _i2 + 1; j < content.length; j++) {
                var canCombine = mergeRulesets.canRulesetsBeCombined(content, _i2, j);
                if (!canCombine) continue;

                if (content[_i2].selector instanceof objects.SelectorList) {
                    if (content[j].selector instanceof objects.SelectorList) {
                        content[_i2].selector.selectors = content[_i2].selector.selectors.concat(content[j].selector.selectors);
                    } else {
                        content[_i2].selector.selectors.push(content[j].selector);
                    }
                } else {
                    if (content[j].selector instanceof objects.SelectorList) {
                        content[_i2].selector = new objects.SelectorList([content[_i2].selector].concat(content[j].selector.selectors));
                    } else {
                        content[_i2].selector = new objects.SelectorList([content[_i2].selector, content[j].selector]);
                    }
                }

                content[_i2] = content[_i2].optimize(kw);

                content.splice(j, 1);
                j--;
            }
        }
    }

    // OPT: Combine adjacent similar rulesets or selectors.
    return _combineAdjacentRulesets(content, kw);
};

function mergeDeclarations(rule, shorthand, longhand) {
    if (!rule.declQualifies(longhand)) {
        return null;
    }
    if (rule.canMerge && !rule.canMerge(shorthand.expr.chain, longhand.expr.chain)) {
        return null;
    }

    var declIdx = rule.decls.indexOf(longhand.ident);
    var newChain = rule.shorthandMerger(shorthand.expr.chain, longhand.expr.chain, declIdx);

    var output = new objects.Declaration(shorthand.ident, new objects.Expression(newChain));

    if (shorthand.important) {
        output.important = true;
    }

    return output;
}

module.exports.optimizeDeclarations = function (content, kw) {
    content = optimizeList(content, kw);
    if (!content.length) return [];

    // OPT: Remove longhand declarations that are overridden by shorthand declarations
    var seenDeclarations = {};

    var _loop = function _loop(i) {
        var decl = content[i];
        if (decl.ident in seenDeclarations) {
            var seen = seenDeclarations[decl.ident];
            if (decl.important && !seen.important) {
                content.splice(content.indexOf(seen), 1);
                seenDeclarations[decl.ident] = decl;
            } else {
                content.splice(i, 1);
            }
            return 'continue';
        }

        // If we match an overridable declaration and we've seen one of the
        // things that overrides it, remove it from the ruleset.
        if (decl.ident in overrideList && overrideList[decl.ident].some(function (ident) {
            return ident in seenDeclarations && seenDeclarations[ident].important >= decl.important;
        })) {
            content.splice(i, 1);
            return 'continue';
        }

        if (decl.ident in shorthandMappingMapped) {
            shorthandMappingMapped[decl.ident].forEach(function (shorthand) {
                // Short circuit if we eliminate this declaration below.
                if (!decl) {
                    return;
                }
                var seenAny = false;
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = shorthand.decls[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var lhDecl = _step3.value;

                        var _seen = seenDeclarations[lhDecl];
                        if (!_seen) {
                            continue;
                        }

                        if (_seen.important && !decl.important) {
                            continue;
                        } else if (decl.important && !_seen.important) {
                            // Remove longhand overridden by important shorthand
                            content.splice(content.indexOf(_seen), 1);
                            delete seenDeclarations[lhDecl];
                            continue;
                        }

                        seenAny = true;
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                if (!seenAny) {
                    return;
                }

                shorthand.decls.forEach(function (lhDeclName) {
                    // Short circuit if we eliminate this declaration below.
                    if (!decl) {
                        return;
                    }

                    var lhDecl = seenDeclarations[lhDeclName];
                    if (!lhDecl) {
                        return;
                    }

                    if (lhDecl.important && !decl.important) {
                        return;
                    }

                    var output = mergeDeclarations(shorthand, decl, lhDecl);
                    // A null result means they could not be merged.
                    if (!output) {
                        return;
                    }

                    content.splice(content.indexOf(lhDecl), 1);
                    delete seenDeclarations[lhDecl.ident];

                    var optimized = output.optimize(kw);
                    if (!optimized) {
                        content.splice(i, 1);
                        decl = null;
                        return;
                    }
                    decl = optimized;
                    content[i] = decl;
                    seenDeclarations[decl.ident] = decl;
                });
            });
            if (!decl) {
                return 'continue';
            }
        }

        seenDeclarations[decl.ident] = decl;
    };

    for (var i = content.length - 1; i >= 0; i--) {
        var _ret = _loop(i);

        if (_ret === 'continue') continue;
    }

    // OPT: Merge together 'piecemeal' declarations when all pieces are specified
    // Ex. padding-left, padding-right, padding-top, padding-bottom -> padding
    shorthandMapping.forEach(function (shMap) {
        var subRules = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = shMap.decls[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var rule = _step.value;

                var seen = seenDeclarations[rule];
                if (!seen || !shMap.declQualifies(seen)) {
                    return;
                }

                subRules.push(seen);
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        if (shMap.allDeclsQualify && !shMap.allDeclsQualify(subRules)) {
            return;
        }

        // Remove the declarations that will be merged
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = subRules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _decl = _step2.value;

                content.splice(content.indexOf(_decl), 1);
                delete seenDeclarations[_decl.ident];
            }
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        var mergedRule = new objects.Declaration(shMap.name, new objects.Expression(shMap.expressionBuilder(subRules)));
        var optimized = mergedRule.optimize(kw);
        content.push(optimized);
        seenDeclarations[shMap.name] = optimized;
    });

    // TODO: Under O1, do these sorts of reductions:
    /*
        border-color: red;
        border-style: solid;
        border-width: 0 0 4px;
    into
        border: 0 solid red;
        border-bottom-width: 4px;
    or
        border: 0 solid red;
        border-width: 0 0 4px;
    */

    // OPT: Sort declarations.
    return content.sort(function (a, b) {
        if (a.ident === b.ident) {
            return a.toString().localeCompare(b.toString());
        }
        return a.ident.localeCompare(b.ident);
    });
};

module.exports.try_ = function (obj, kw) {
    if (!obj) return obj;
    if (obj.optimize) return obj.optimize(kw);
    return obj;
};

// Units to be optimize when using --O1 only.
var opt_unit_o1_only = {
    cm: true,
    mm: true,
    q: true,
    turn: true
};
var length_units = {
    'in': 96,
    px: 1,
    pt: 4 / 3,
    pc: 16,
    cm: 37.79,
    mm: 3.779,
    q: 37.79 / 40 // 1/40 of a cm
};
var angular_units = {
    deg: 1,
    rad: 180 / Math.PI,
    grad: 9 / 10,
    turn: 360
};
var temporal_units = {
    s: 1000,
    ms: 1
};
var frequency_units = {
    Hz: 1,
    kHz: 1000
};
var resolution_units = {
    dpi: 1,
    dpcm: 1 / 2.54,
    dppx: 1 / 96
};

module.exports.unit = function (unit, kw) {
    function optimizeMin(unit, units) {
        var versions = {};
        var base_unit = units[unit.unit] * unit.number.asNumber();
        var shortest = void 0;
        var shortestLen = unit.toString().length;

        for (var i in units) {
            if (!kw.o1 && i in opt_unit_o1_only || i === 'turn' || i === unit.unit) continue;
            var temp = versions[i] = new objects.Dimension(new objects.Number(base_unit / units[i]), i);
            if (temp.toString().length < shortestLen) {
                shortest = i;
                shortestLen = temp.toString().length;
            }
        }
        return !shortest ? unit : versions[shortest];
    }

    switch (unit.unit) {
        // Length units
        case 'cm':
        case 'mm':
        case 'q':
            if (!kw.o1) return unit;
        case 'in':
        case 'px':
        case 'pt':
        case 'pc':
            return optimizeMin(unit, length_units);
        // Angular units
        case 'deg':
        case 'rad':
        case 'grad':
        case 'turn':
            return optimizeMin(unit, angular_units);
        // Temporal units
        case 's':
        case 'ms':
            return optimizeMin(unit, temporal_units);
        // Frequency units
        case 'Hz':
        case 'kHz':
            return optimizeMin(unit, frequency_units);
        // Resolution units
        case 'dpi':
        case 'dpcm':
        case 'dppx':
            return optimizeMin(unit, resolution_units);
        default:
            return unit;
    }
};

module.exports.combineList = function (mapper, reducer, list) {
    var values = {};
    for (var i = 0; i < list.length; i++) {
        var lval = mapper(list[i]);
        if (!(lval in values)) values[lval] = list[i];else values[lval] = reducer(values[lval], list[i]);
    }
    var output = [];
    for (var key in values) {
        if (values.hasOwnProperty(key)) {
            output.push(values[key]);
        }
    }
    return output;
};